bs.list#
}
boxscore()
Sys.Date()
boxscore(date = "2011-10-23")
boxscore( "2011-10-23")
boxscore( "2011/10/23")
boxscore( date="2011/10/23")
boxscore( as.POSIXCT"2011/10/23"))
boxscore( as.POSIXCT()"2011/10/23"))
boxscore( as.POSIXCT("2011/10/23"))
boxscore( as.POSIXct("2011/10/23"))
boxscore("2011/10/23")
boxscore(Sys.Date())
boxscore(Sys.Date()-1)
gamexml <- function(date = Sys.Date()-1) {#
if(date > Sys.Date())#
stop("Cannot retrieve scores from the future.")#
#
year  <- paste("year_", format(date, "%Y"), "/", sep = "")#
month <- paste("month_", format(date, "%m"), "/", sep = "")#
day   <- paste("day_", format(date, "%d"), "/", sep = "")#
#
xmlFile <-#
paste("http://gd2.mlb.com/components/game/mlb/",#
year, month, day, "miniscoreboard.xml", sep = "")#
xmlTree <- xmlTreeParse(xmlFile, useInternalNodes = TRUE)#
xp <- xpathApply(xmlTree, "//game")#
xp#
}
gamexml
gamexml()
boxscore <- function(date = Sys.Date()) {#
if(date > Sys.Date())#
stop("Cannot retrieve scores from the future.")#
#
year  <- paste("year_", format(date, "%Y"), "/", sep = "")#
month <- paste("month_", format(date, "%m"), "/", sep = "")#
day   <- paste("day_", format(date, "%d"), "/", sep = "")#
#
xmlFile <-#
paste("http://gd2.mlb.com/components/game/mlb/",#
year, month, day, "miniscoreboard.xml", sep = "")#
xmlTree <- xmlTreeParse(xmlFile, useInternalNodes = TRUE)#
xp <- xpathApply(xmlTree, "//game")#
xmlList <- lapply(xp, xmlToList)#
#
bs.list <- lapply(xmlList, createBoxScore)#
names(bs.list) <-#
paste(sapply(bs.list, "[[", "away.team"),#
"@",#
sapply(bs.list, "[[", "home.team"))#
bs.list#
}#
#
gamexml <- function(date = Sys.Date()) {#
if(date > Sys.Date())#
stop("Cannot retrieve scores from the future.")#
#
year  <- paste("year_", format(date, "%Y"), "/", sep = "")#
month <- paste("month_", format(date, "%m"), "/", sep = "")#
day   <- paste("day_", format(date, "%d"), "/", sep = "")#
#
xmlFile <-#
paste("http://gd2.mlb.com/components/game/mlb/",#
year, month, day, "miniscoreboard.xml", sep = "")#
xmlTree <- xmlTreeParse(xmlFile, useInternalNodes = TRUE)#
xp <- xpathApply(xmlTree, "//game")#
xp#
}#
#
#
#
#
#
bs <- boxscore(date = Sys.Date()-1)
bs
bs.df <- do.call(rbind, lapply(bs, as.data.frame))
#
bs.df$updated <-  Sys.time() #
write.table(bs.df,file="~/Dropbox/Public/boxscore.csv",sep=",",na="",row.names=FALSE)#
write.table(bs.df,file="~/Dropbox/Public/boxscore.txt",sep="\t",na="",row.names=FALSE)
gamexml
gamexml()
gamexml(Sys.Date()-1)
bs.df <- do.call(rbind, lapply(bs, as.data.frame))
bs.df
library(XML)#
#
## create a boxscore object from an XML description of a game#
createBoxScore <- function(x) {#
status <- if(x$.attrs["status"] != "In Progress")#
"Final" else if(x$.attrs["top_inning"] == "Y")#
"Top" else "Bot"#
#
bs <- list(status = status,#
inning = as.numeric(x$.attrs["inning"]),#
away.team = x$.attrs["away_name_abbrev"],#
away.runs = as.numeric(x$.attrs["away_team_runs"]),#
away.hits = as.numeric(x$.attrs["away_team_hits"]),#
away.errors = as.numeric(x$.attrs["away_team_errors"]),#
home.team = x$.attrs["home_name_abbrev"],#
home.runs = as.numeric(x$.attrs["home_team_runs"]),#
home.hits = as.numeric(x$.attrs["home_team_hits"]),#
home.errors = as.numeric(x$.attrs["home_team_errors"]))#
class(bs) <- "boxscore"#
bs#
}#
#
## print the boxscore object in traditional format#
print.boxscore <- function(x, ...) {#
cat("     ", "R   ", "H  ", "E (",#
x$status, " ",#
x$inning, ")\n",#
format(x$away.team, width = 3), " ",#
format(x$away.runs, width = 2), "  ",#
format(x$away.hits, width = 2), "  ",#
x$away.errors, "\n",#
format(x$home.team, width = 3), " ",#
format(x$home.runs, width = 2), "  ",#
format(x$home.hits, width = 2), "  ",#
x$home.errors, "\n\n", sep = "")#
}#
#
## utility function ...#
as.data.frame.boxscore <- function(x, row.names, optional, ...) {#
class(x) <- "list"#
as.data.frame(x)#
}#
#
## This is the "user accessible" public function you should be calling!#
## downloads the XML data, and prints out boxscores for games on "date"#
boxscore <- function(date = Sys.Date()) {#
if(date > Sys.Date())#
stop("Cannot retrieve scores from the future.")#
#
year  <- paste("year_", format(date, "%Y"), "/", sep = "")#
month <- paste("month_", format(date, "%m"), "/", sep = "")#
day   <- paste("day_", format(date, "%d"), "/", sep = "")#
#
xmlFile <-#
paste("http://gd2.mlb.com/components/game/mlb/",#
year, month, day, "miniscoreboard.xml", sep = "")#
xmlTree <- xmlTreeParse(xmlFile, useInternalNodes = TRUE)#
xp <- xpathApply(xmlTree, "//game")#
xmlList <- lapply(xp, xmlToList)#
#
bs.list <- lapply(xmlList, createBoxScore)#
names(bs.list) <-#
paste(sapply(bs.list, "[[", "away.team"),#
"@",#
sapply(bs.list, "[[", "home.team"))#
bs.list#
}#
#
gamexml <- function(date = Sys.Date()) {#
if(date > Sys.Date())#
stop("Cannot retrieve scores from the future.")#
#
year  <- paste("year_", format(date, "%Y"), "/", sep = "")#
month <- paste("month_", format(date, "%m"), "/", sep = "")#
day   <- paste("day_", format(date, "%d"), "/", sep = "")#
#
xmlFile <-#
paste("http://gd2.mlb.com/components/game/mlb/",#
year, month, day, "miniscoreboard.xml", sep = "")#
xmlTree <- xmlTreeParse(xmlFile, useInternalNodes = TRUE)#
xp <- xpathApply(xmlTree, "//game")#
xp#
}#
#
#
#
#
#
bs <- boxscore(date = Sys.Date()-1)#
#
bs.df <- do.call(rbind, lapply(bs, as.data.frame))#
#
bs.df$updated <-  Sys.time() #
write.table(bs.df,file="~/Dropbox/Public/boxscore.csv",sep=",",na="",row.names=FALSE)#
write.table(bs.df,file="~/Dropbox/Public/boxscore.txt",sep="\t",na="",row.names=FALSE)
bs.df
#
#
data(baseball)#
#
#To do this for all players, we first make a function:#
calculate_cyear <- function(df) { #
within(df, {#
cyear <- year - min(year) + 1 #
cpercent <- cyear / max(cyear)#
})#
}#
#
baseball <- ddply(baseball, .(id), calculate_cyear)#
#baseball <- subset(baseball, ab >= 25)#
#
bbsub <- subset(baseball, id %in% c('aaronha01','ruthba01','mcgwima01', 'bondsba01'))#
# Example search: baseball[grep('bond', baseball$id),]#
#
xlim <- range(bbsub$cyear, na.rm=TRUE) #
ylim <- range(bbsub$hr/ bbsub$ab, na.rm=TRUE) #
#
plotpattern <- function(df) {#
qplot(cyear, hr / ab, data = df, geom="line", xlim = xlim, ylim = ylim)#
}#
pdf("paths.pdf", width=8, height=4) #
d_ply(bbsub, .(reorder(id, hr / ab)), failwith(NA, plotpattern),#
.print = TRUE) #
dev.off()#
#
ggplot(bbsub, aes(x=cyear,y=hr)) + geom_line() + facet_grid( id ~. ) + geom_text(aes(label=year))#
#
ggplot(bbsub, aes(x=cyear,y=hr,color=id)) + geom_line()  + geom_text(aes(label=year))
library(ggplot2)
#
#
data(baseball)#
#
#To do this for all players, we first make a function:#
calculate_cyear <- function(df) { #
within(df, {#
cyear <- year - min(year) + 1 #
cpercent <- cyear / max(cyear)#
})#
}#
#
baseball <- ddply(baseball, .(id), calculate_cyear)#
#baseball <- subset(baseball, ab >= 25)#
#
bbsub <- subset(baseball, id %in% c('aaronha01','ruthba01','mcgwima01', 'bondsba01'))#
# Example search: baseball[grep('bond', baseball$id),]#
#
xlim <- range(bbsub$cyear, na.rm=TRUE) #
ylim <- range(bbsub$hr/ bbsub$ab, na.rm=TRUE) #
#
plotpattern <- function(df) {#
qplot(cyear, hr / ab, data = df, geom="line", xlim = xlim, ylim = ylim)#
}#
pdf("paths.pdf", width=8, height=4) #
d_ply(bbsub, .(reorder(id, hr / ab)), failwith(NA, plotpattern),#
.print = TRUE) #
dev.off()#
#
ggplot(bbsub, aes(x=cyear,y=hr)) + geom_line() + facet_grid( id ~. ) + geom_text(aes(label=year))#
#
ggplot(bbsub, aes(x=cyear,y=hr,color=id)) + geom_line()  + geom_text(aes(label=year))
install.packages('ProjectTemplate')
install.packages('ProjectTemplate')
install.packages('ProjectTemplate')
cd ~/Code/
cd ~\Code
cd
setwd("~/Code")
require(ProjectTemplate)
create.project('MSHA')
setwd("MSHA")
#
skip_count <- 250000#
start_row <- skip_count + 1#
#
idat <- read.table('../data/msha_source/Inspections.TXT', nrows=skip_count, header=T, sep="|", fill=T, as.is=c(1:45), quote="",comment.char = "")#
inames <- names(idat)#
#
idat <- merge(mdat_wv[c("MINE_ID","CURRENT_MINE_TYPE")] , idat )#
#
while (start_row < 2000000) {#
     print(paste("About to scan records ", start_row, " through " , start_row + skip_count))#
#
	idat_temp <- read.table('../data/msha_source/Inspections.TXT', nrows=skip_count, header=F, sep="|", fill=T, as.is=c(1:45), skip = start_row ,quote="",comment.char = "")#
	names(idat_temp) <- inames#
	idat <- rbind(idat, merge(mdat_wv[c("MINE_ID","CURRENT_MINE_TYPE")] , idat_temp ))#
	print(paste("Rows collected: " , nrow(idat)))#
	start_row <- start_row + skip_count#
}#
#
write.csv(vdat, "../data/wv_idat.csv")
dir()
#
skip_count <- 250000#
start_row <- skip_count + 1#
#
idat <- read.table('./data/msha_source/Inspections.TXT', nrows=skip_count, header=T, sep="|", fill=T, as.is=c(1:45), quote="",comment.char = "")#
inames <- names(idat)#
#
idat <- merge(mdat_wv[c("MINE_ID","CURRENT_MINE_TYPE")] , idat )#
#
while (start_row < 2000000) {#
     print(paste("About to scan records ", start_row, " through " , start_row + skip_count))#
#
	idat_temp <- read.table('./data/msha_source/Inspections.TXT', nrows=skip_count, header=F, sep="|", fill=T, as.is=c(1:45), skip = start_row ,quote="",comment.char = "")#
	names(idat_temp) <- inames#
	idat <- rbind(idat, merge(mdat_wv[c("MINE_ID","CURRENT_MINE_TYPE")] , idat_temp ))#
	print(paste("Rows collected: " , nrow(idat)))#
	start_row <- start_row + skip_count#
}#
#
write.csv(idat, "./data/wv_idat.csv")
mdat <- read.table('./data/Mines.TXT', header=T, sep="|", fill=T, as.is=c(1:59),quote="")#
mdat_wv <- subset(mdat, STATE == 'WV' & COAL_METAL_IND == 'C')
mdat <- read.table('./data/msha_source/Mines.TXT', header=T, sep="|", fill=T, as.is=c(1:59),quote="")#
mdat_wv <- subset(mdat, STATE == 'WV' & COAL_METAL_IND == 'C')
#
skip_count <- 250000#
start_row <- skip_count + 1#
#
idat <- read.table('./data/msha_source/Inspections.TXT', nrows=skip_count, header=T, sep="|", fill=T, as.is=c(1:45), quote="",comment.char = "")#
inames <- names(idat)#
#
idat <- merge(mdat_wv[c("MINE_ID","CURRENT_MINE_TYPE")] , idat )#
#
while (start_row < 2000000) {#
     print(paste("About to scan records ", start_row, " through " , start_row + skip_count))#
#
	idat_temp <- read.table('./data/msha_source/Inspections.TXT', nrows=skip_count, header=F, sep="|", fill=T, as.is=c(1:45), skip = start_row ,quote="",comment.char = "")#
	names(idat_temp) <- inames#
	idat <- rbind(idat, merge(mdat_wv[c("MINE_ID","CURRENT_MINE_TYPE")] , idat_temp ))#
	print(paste("Rows collected: " , nrow(idat)))#
	start_row <- start_row + skip_count#
}#
#
write.csv(idat, "./data/wv_idat.csv")
skip_count <- 250000#
start_row <- skip_count + 1#
#
idat <- read.table('./data/msha_source/Inspections.TXT', nrows=skip_count, header=T, sep="|", fill=T, as.is=c(1:44), quote="",comment.char = "")#
inames <- names(idat)#
#
idat <- merge(mdat_wv[c("MINE_ID","CURRENT_MINE_TYPE")] , idat )#
#
while (start_row < 2000000) {#
     print(paste("About to scan records ", start_row, " through " , start_row + skip_count))#
#
	idat_temp <- read.table('./data/msha_source/Inspections.TXT', nrows=skip_count, header=F, sep="|", fill=T, as.is=c(1:44), skip = start_row ,quote="",comment.char = "")#
	names(idat_temp) <- inames#
	idat <- rbind(idat, merge(mdat_wv[c("MINE_ID","CURRENT_MINE_TYPE")] , idat_temp ))#
	print(paste("Rows collected: " , nrow(idat)))#
	start_row <- start_row + skip_count#
}#
#
write.csv(idat, "./data/wv_idat.csv")
#
skip_count <- 250000#
start_row <- skip_count + 1#
#
idat <- read.table('./data/msha_source/Inspections.TXT', nrows=skip_count, header=T, sep="|", fill=T, as.is=c(1:43), quote="",comment.char = "")#
inames <- names(idat)#
#
idat <- merge(mdat_wv[c("MINE_ID","CURRENT_MINE_TYPE")] , idat )#
#
while (start_row < 2000000) {#
     print(paste("About to scan records ", start_row, " through " , start_row + skip_count))#
#
	idat_temp <- read.table('./data/msha_source/Inspections.TXT', nrows=skip_count, header=F, sep="|", fill=T, as.is=c(1:43), skip = start_row ,quote="",comment.char = "")#
	names(idat_temp) <- inames#
	idat <- rbind(idat, merge(mdat_wv[c("MINE_ID","CURRENT_MINE_TYPE")] , idat_temp ))#
	print(paste("Rows collected: " , nrow(idat)))#
	start_row <- start_row + skip_count#
}#
#
write.csv(idat, "./data/wv_idat.csv")
idat <- read.table('./data/msha_source/Inspections.TXT', nrows=skip_count, header=T, sep="|", fill=T,  quote="",comment.char = "")
inames <- names(idat)#
#
idat <- merge(mdat_wv[c("MINE_ID","CURRENT_MINE_TYPE")] , idat )#
#
while (start_row < 2000000) {#
     print(paste("About to scan records ", start_row, " through " , start_row + skip_count))#
#
	idat_temp <- read.table('./data/msha_source/Inspections.TXT', nrows=skip_count, header=F, sep="|", fill=T,  skip = start_row ,quote="",comment.char = "")#
	names(idat_temp) <- inames#
	idat <- rbind(idat, merge(mdat_wv[c("MINE_ID","CURRENT_MINE_TYPE")] , idat_temp ))#
	print(paste("Rows collected: " , nrow(idat)))#
	start_row <- start_row + skip_count#
}#
#
write.csv(idat, "./data/wv_idat.csv")
idat <- NULL
idat <- read.csv("../data/wv_idat.csv")
idat <- read.csv("./data/wv_idat.csv")
adat <- read.table('./data/msha_source/Accidents.TXT', header=T, sep="|", fill=T, as.is=c(1:58), quote="",comment.char = "")#
# WV is FIPS 54#
adat <- subset(adat, FIPS_STATE_CD==54)
adat <- read.table('./data/msha_source/Accidents.TXT', header=T, sep="|", fill=T, quote="",comment.char = "")#
# WV is FIPS 54#
adat <- subset(adat, FIPS_STATE_CD==54)
ls()
idat_temp <- NULL
mdat <- NULL
str(mdat_wv)
str(idat)
str(adat)
str(vdat)
vdat <- read.csv("./data/wv_vdat.csv")
str(vdat)
head(mdat_wv)
merge(idat, mdat_wv[,c('CURRENT_MINE_NAME','CURRENT_CONTROLLER_NAME')])
head(merge(idat, mdat_wv[,c('MINE_ID','CURRENT_MINE_NAME','CURRENT_CONTROLLER_NAME')]))
idat <- merge(idat, mdat_wv[,c('MINE_ID','CURRENT_MINE_NAME','CURRENT_CONTROLLER_NAME')])
adat <- merge(adat, mdat_wv[,c('MINE_ID','CURRENT_MINE_NAME','CURRENT_CONTROLLER_NAME')])
vdat <- merge(vdat, mdat_wv[,c('MINE_ID','CURRENT_MINE_NAME','CURRENT_CONTROLLER_NAME')])
head(vdat)
ddply(head(vdat,500), "VIOLATOR_NAME", transform, n_violator = length(VIOLATOR_NAME))
